강사님 깃허브
https://github.com/Jiwoong-Jung/202407Java

타입은 메모리에 저장되는 방식을 말한다.

btye타입끼리 연산을 할 때 int형으로 자동 변환되어 계산되기 때문에 결과는 int형으로 나온다.
byte b1 = 1;
byte b2 = 2;
byte b3 = (byte) b1+b2;

String 내장함수로 문자열을 반복해 붙여주는 repeat(int n)메서드가 있다.

자바에선 배열 생성시 자동 초기화

int scores[] = new int[] {83,90,87};
int scores2[] = {83,90,87};
두 문장은 같다.

Set<Integer> lottoSet = new HashSet<>();	//	중복을 허용하지 않는 Set 사용
<Integer>는 제네릭

System.out.printf("국어점수: %3.2f\n",score);	//	3은 확보할 공간의 자릿수, .2는 소수점 자릿수 지정

바이트 -> InputStream -> ObjectInputStream(역직렬화) -> 객체 -> ObjectOutputStream(직렬화) -> OutputStream -> 바이트

java.io.NotSerializableException : 직렬화 하지 않음.

arraycopy("복사할 배열명", 복사 시작 인덱스, "붙여넣을 배열명", 붙여넣기 시작 인덱스, "복사할 문자 수");	// 배열복사

자료구조를 사용해 객체들을 효율적으로 추가 삭제 검색할 수 있도록 인터페이스와 구현 클래스를 java.util 패키지에서 제공하며 
이를 총칭해 컬렉션 프레임워크라 한다.

열거형(enum)은 상수만을 다루는 클래스이다.
enum 열거형 명{값1, 값2....값n} 으로 선언한다.

이터레이터(자바 디자인 패턴 = 객체지향 코딩 패턴) = 반복자

Iterator<String> it = list.iterator();
		while(it.hasNext()) {
			String str = it.next();
			System.out.println(str);
		}

courses.contains(course)	// course가 courses에 존재하는지 확인

프로젝트 우클릭 > Build Path > Configure build path > library > classpath > add external jars로 라이브러리 임포트 가능

생성자는 특별한 메소드로, 반환타입이 존재하지 않음.

생성자가 다른 생성자를 호출 시 반드시 호출 먼저 해야한다.(this(), super()가 첫번째 줄)

this는 객체 자신에 대한 레퍼런스(참조)이다.

모든 클래스의 부모는 Object, 자식 클래스에서 인스턴스를 생성하기 위해서 부모 클래스의 생성자를 호출해야함(Object는 그 메소드를 사용하지
않으면 호출할 필요 없음)

인터페이스는 상수와 추상클래스만 소유 가능

인스턴스 멤버 클래스는 static 키워드없이 중첩 선언된 클래스를 의미

인스턴스는 클래스를 이용해 생성해야 사용 가능한 필드
정적 멤버는 static

자식 객체가 재정의된 메소드를 가지고 있으면, 부모 타입으로 자동 타입 변환 후에 메소드를 호출하면 재정의된 자식 메소드가 호출된다. = 다형성

인터페이스에서 필드는 무조건 public static final이다. 생략가능
인터페이스도 상속관계에서 일어나는 자동 타입 변환이 가능하다.
인터페이스간 상속은 implements가 아닌 extends이다. 그러므로 상속받은 인터페이스의 메소드를 구현할 필요가 없다. 또한 인터페이스간 다중상속이 가능
인터페이스를 익명객체로 사용시 즉시 구현하여 사용이 가능
plus.addActionListener(new ActionListener() { /* 구현 코드 */ });

에러는 고장, 예외는 사용자의 잘못된 조작 또는 개발자의 잘못된 코딩으로 인해 발생하는 프로그램 오류
예외는 발생 시점에 따라 일반 예외와 실행 예외로 나뉜다.
Class.forName()	// 이 클래스가 존재하는지 확인

중첩 클래스는 클래스명$중첩 클래스명.class 형태로 bin 파일에 저장된다.(A$B.class)
메소드 내에서 클래스를 선언하면 클래스명$1로컬클래스.class 형태로 저장된다.
로컬 클래스는 메소드 안에 선언된 클래스

인스턴스 멤버 클래스는 static 키워드 없이 중첩 선언된 클래스를 의미한다. 인스턴스 멤버 클래스는 인스턴스 필드와 메소드만 선언이 가능하고,
정적 필드와 메소드는 선언할 수 없다. 자바 17부턴 static 가능
일반적으로 A(외부 클래스)에서 B(내부 클래스) 객체를 생성하는 일은 거의 없다. 대부분 A(외부 클래스) 내부에서 B(내부 클래스) 객체를 생성해 사용한다.

프로세서(CPU)
프로세스(실행중인 프로그램)
멀티 프로세스 -> 리눅스, 유닉스, 과거 윈도우즈에선 불가능했다.
스레드(프로세스 내부에서 

String sql = String.format("insert into dept value(%d, '%s', '%s')", deptno, dname, loc);	// format함수로 문자열에 변수를 넣어 문자열로 만들 수 있음.

로컬 스레드는 메소드를 실행하는 스레드와 다르므로 메소드가 종료된 후에도 로컬 스레드 객체는 실행 상태로 존재할 수 있다.
이를 해결하기 위해 컴파일시 로컬 클래스에서 사용하는 매개 변수나 로컬 변수의 값을 로컬 클래스 내부에 복사해두고 사용한다. 그러므로 매개 변수나
로컬 변수가 수정되어 값이 변경되면 로컬 클래스에 복사해둔 값과 달라지므로 이를 해결하기 위해 final로 선언할 것을 요구한다.

final 특성을 가진 매개 변수나 로컬 변수만 로컬 클래스 내부에서 사용할 수 있다. 자바8 이후부턴 매개 변수와 로컬 변수는 final로 자동 치환된다.

로컬 클래스에서 외부 클래스의 필드를 사용하려면 외부클래스명.this.필드명 으로 호출한다.

람다식은 (매개변수)->{메서드구현코드} 으로 사용하며, 인터페이스에서만 가능하고 구현하는 메서드가 하나여야 한다.(함수형 인터페이스)
@FunctionalInterface를 인터페이스 위에 붙이면 이상이 있을시 오류를 띄워준다. 추상 클래스의 형태에 따른 리턴값과 매개변수를 가진다. 
람다식은 매개변수가 하나일시 소괄호 생략가능. 구현코드가 한줄일 시에 중괄호 생략가능.(return문일 경우 생략 불가능)

표준 API(Application Programming Interface)
Consumer

SOLID 설계 원칙
단일 책임 원칙: 객체는 단 하나의 책임만 가져야함
개방 폐쇠 원칙: 기존 코드를 변경하지 않으면서 기능을 추가할 수 있어야 함
ㄴ 기존 것을 수정할 시 다른 코드들에 영향이 가기 때문
리스코프 치환 원칙: 부모 클래스와 자식 클래스 사이의 행위가 일관성이 있어야 함
의존 역전 원칙: 의존관계를 맺을 때 변화하기 어려운 것에 의존해야 한다
인터페이스 분리 원칙: 인터페이스를 클라이언트에 특화되도록 분리해야 한다

자바의 구조 디자인 패턴
반복자 Iterator<E> / Iterable<E>: 컬렉션의 요소들의 기본 표현을 노출하지 않고 하나씩 모두를 순회할 수 있는 디자인 패턴
Adapter: 호환되지 않는 인터페이스를 가진 객체들이 협업할 수 있도록 하는 구조적 디자인 패턴
TemplateMethod: 부모 클래스에 대략적인 틀을 정의해놓고 자식 클래스로 자세한 사항을 구현하는 디자인 패턴
Singleton: 하나의 인스턴스만 갖는 클래스를 제공하는 디자인 패턴